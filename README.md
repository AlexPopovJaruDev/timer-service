# Timer Service

Небольшой Spring Boot-сервис, который раз в заданный интервал (1 секунда по ТЗ) публикует текущее время во внутреннюю очередь и асинхронно сохраняет его в PostgreSQL по одному или батчами.  


## Функциональность

- Продюсер (`TimeProducer`) по расписанию создает объект `LocalDateTime.now()` и кладет в очередь (`TimeQueueStorage`).
- Консьюмер (`TimeConsumer`):
  - читает очередь в отдельном потоке;
  - пишет в БД по одному или батчами;
  - при проблемах с БД делает паузу и не «молотит» её в цикле.
- Мониторинг БД (`DbHealthMonitor`):
  - при ошибке соединения помечает БД как недоступную;
  - отдельной задачей «пингует» её по расписанию до восстановления.
- REST API:
  - `GET /api/time/all` - вернуть все сохранённые временные метки.

---

## Стэк

### Java & Spring Boot

- **Java 17** 
- **Spring Boot 3 (Web + Data JDBC + Scheduling)**
- **PostgreSQL 17** - основная БД.
- **Liquibase** - миграции схемы БД (таблица `time_entry` создаётся при старте).
- **Logback** - логирование в консоль и в файл с ротацией.
- **Testcontainers + JUnit 5** (в тестах) - интеграционные тесты с живым Postgres в контейнере.
  

### Почему Spring Data JDBC, а не JPA/Hibernate

- Модель данных - одна простая таблица `time_records(time TIMESTAMP PRIMARY KEY)`.
JDBC здесь полностью справляется со всеми необходимыми задачами, JPA/Hibernate, как мне кажется, здесь не требуется

### Почему внутренняя очередь, а не Kafka/RabbitMQ

- В рамках такого небольшого тестового задания, на мой взгляд, использование и поддержание инфраструктуры брокеров - явный оверинжиниринг. 
По ТЗ необходимо обеспечить сохранность и консистентность данных на случай падения БД, а не всего приложения, поэтому был выбран более легковестный и
соответствующий размеру/сложности/требованиям к сохранности данных механизм - внутренняя потокобезопастная очередь `LinkedBlockingDeque<LocalDateTime>` в `TimeQueueStorage`,
то есть постарался реализовать **легковесный, но расширяемый** вариант.

---

## Архитектура (в двух словах)

- `TimeProducer` - по `@Scheduled` кладёт время в `TimeQueueStorage`
- `TimeQueueStorage` - in-memory очередь с лимитом
- `TimeConsumer` - отдельный поток:
  - смотрит размер очереди
  - пишет по одному либо батчами через `TimeService`
- `TimeService` / `TimeRepository` - слой работы с БД через `JdbcTemplate`
- `InternalExceptionHandler` - если проблема с соединением:
  - возвращает записи в начало очереди,
  - помечает БД как недоступную
- `DbHealthMonitor` + `DbHealthRepository` - периодический `SELECT 1` до восстановления соединения
- `GlobalExceptionHandler` - аккуратные JSON-ответы и статусы в случае ошибок БД

---

## Быстрый старт через Docker Compose

### Предварительные требования

- Docker
- Docker Compose
- Клонированный репозиторий

### Переменные окружения

В приложении предусмотрено использование переменных окружения. Все они имеют дефолтные значения, достаточные для запуска, для их переопределения
можно в корне проекта реализовать файл .env, это предусмотрено в application.yaml:

```
spring:
  config:
    import: optional:file:.env[.properties]
```
Основные переменные окружения:
- DB_DATABASE - имя базы данных (по умолчанию timer_service)
- DB_USERNAME - пользователь БД (по умолчанию test)
- DB_PASSWORD - пароль к БД (по умолчанию test)
- DB_URL - URL для подключения к БД
- DB_DRIVER - драйвер JDBC (по умолчанию org.postgresql.Driver)
- TIMER_SERVICE_LOG_LEVEL - уровень логирования (INFO / DEBUG и т.д.)
- TIMER_TIMEZONE - таймзона приложения

Пример .env:

```
DB_DATABASE=timer_service
DB_USERNAME=test
DB_PASSWORD=test
DB_URL=jdbc:postgresql://localhost:5432/timer_service
DB_DRIVER=org.postgresql.Driver
TIMER_SERVICE_LOG_LEVEL=INFO
TIMER_TIMEZONE=Europe/Moscow
```

### Запуск
В репозитории есть docker-compose.yaml, который поднимает:
- timer-service-postgres - контейнер с PostgreSQL
- timer-service - Spring Boot приложение

Для быстрого запуска через командную строку необходимо из корневой директории проекта (с файлом `docker-compose.yaml`) использовать команду 
```
docker compose up
```

После старта:
- приложение доступно на localhost:8080
- БД доступно на localhost:5432 (если проброшен порт по умолчанию)

Для проверки работоспособности можно отправить запрос (базово `http://localhost:8080/api/time/all`), а для проверки устойчивости можно в Докере остановить `timer-service-postgres`, 
подождать/отправить запросы по эндпоинту `/api/time/all`, после чего вновь запустить `timer-service-postgres`. После восстановления соединения данные, которые во время его отсутствия 
писались только во внутреннюю очередь, будут записаны в БД.

### Локальный Postgres только (опционально)

Есть отдельный `docker-compose-postgres.yaml` файл только для БД (локальная разработка), его можно использовать, если хотите запускать приложение напрямую из IDE, а БД держать в контейнере.
